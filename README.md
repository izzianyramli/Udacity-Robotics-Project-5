# Udacity-Robotics-Project5
Udacity Robotics Software Engineer Nanodegree - Project 5: Home Service Robot

## Packages Description
This repo contains several packages that is needed for mapping, localization and navigation:
1. `my_robot`: This package includes several things needed for the overall application:

-- `config/`: contains configuration files needed for localization and navigation.

-- `launch/`: contains the launch scripts that will be called in the bash scripts.

-- `maps/`: contains the map data to be used for navigation.

-- `rvizConfig/`: contains the pre-configured RViz configuration for mapping and navigation.

-- `worlds/`: contains the Gazebo simulation environment.

-- `urdf/`: contains robot body and sensors defined.

-- `meshes/`: contains data on for Robot's Hokuyo laser sensor.

2. `slam_gmapping`: This package contains SLAM algorithm that is used to map the enviroment.

You may need to change the param based on your simulation environment in `slam_gmapping/gmapping/src/slam_gmapping.cpp`:
```cpp
  // Parameters used by our GMapping wrapper
  if(!private_nh_.getParam("throttle_scans", throttle_scans_))
    throttle_scans_ = 1;
  if(!private_nh_.getParam("base_frame", base_frame_))
    base_frame_ = "base_link";
  if(!private_nh_.getParam("map_frame", map_frame_))
    map_frame_ = "map";
  if(!private_nh_.getParam("odom_frame", odom_frame_))
    odom_frame_ = "odom";
```

3. `teleop_twist_keyboard`: This package contains robot teleoperation package that is used to manually control and move the robot using keyboard for testing, especially while doing mapping. 
4. `add_markers`: Package for adding cube markers in RViz to be used in home service robot application, to visualize object being picked up and dropped off by the robot.
5. `pick-objects`: Package for adding multiple navigation goal for the robot to navigate within the Gazebo environment.

### Mapping
<b>Package Name</b>: `slam_gmapping`

<b>Purpose</b>: The `slam_gmapping` package is used for creating a map of an environment while simultaneously localizing the robot within that map. It implements a SLAM (Simultaneous Localization and Mapping) algorithm based on the GMapping approach, which utilizes laser scan data and odometry information.

<b>Functionality</b>: In my home service robot project, the `slam_gmapping` node is essential for generating a 2D occupancy grid map of the environment as the robot navigates through it. The node processes data from the robot's LIDAR sensor to detect obstacles and free space, allowing it to build a comprehensive map in real-time.

<b>Integration</b>: The slam_gmapping node integrates with other components of the ROS ecosystem, such as the `robot_pose_ekf` package for improving the robot's pose estimation and the `amcl` package for localization. The map generated by `slam_gmapping` is then used by the `amcl` node to help the robot determine its position accurately within the created map.

<b>Challenges and Solutions</b>: During the implementation of the `slam_gmapping` node, I encountered issues with map distortion due to rapid movements of the robot. To address this, I adjusted the parameters related to the scan matching and increased the frequency of odometry updates. This helped improve the accuracy of the generated map. Also, it is also help to drive the robot with minimum velocity while mapping the area.

<b>References</b>: For more information on the `slam_gmapping` package, you can refer to the [ROS Wiki](http://wiki.ros.org/slam_gmapping) page on `slam_gmapping`.

### Localization
<b>Package Name</b>: AMCL (Adaptive Monte Carlo Localization)

</b>Purpose</b>: The `amcl` package is used for the localization of a robot within a known map. It employs a particle filter to estimate the robot's pose (position and orientation) based on sensor data and the map.

<b>Functionality</b>: In my home service robot project, the `amcl` node plays a crucial role in enabling the robot to determine its location as it navigates through the environment. By utilizing laser scan data from the robot's LIDAR sensor, `amcl` matches the observed features in the environment with the pre-existing map, allowing the robot to accurately localize itself.

<b>Integration</b>: The `amcl` node works in conjunction with the `gmapping` package, which is responsible for creating the map of the environment. Once the map is generated, `amcl` uses this map to provide real-time localization updates as the robot moves. The output from `amcl` is then fed into the navigation stack, specifically the `move_base` node, which uses the localization data to plan and execute paths to designated goals.

<b>Challenges and Solutions</b>: During the implementation of the `amcl` node, I encountered issues with the robot's localization drifting over time. To mitigate this, I adjusted the parameters for the particle filter, specifically increasing the number of particles and tuning the sensor noise parameters to improve the accuracy of the localization.

<b>References</b>: For more information on the `amcl` package, you can refer to the [ROS Wiki](http://wiki.ros.org/amcl) page on AMCL.

### Navigation
<b>Package Name</b>: `ros_navigation`

<b>Purpose</b>: The `ros_navigation` package is a comprehensive suite of tools and algorithms designed to enable mobile robots to navigate autonomously within an environment. It provides functionalities for path planning, obstacle avoidance, and localization, allowing robots to move safely and efficiently from one point to another.

<b>Functionality</b>: In my home service robot project, the `ros_navigation` package is integral to the robot's ability to navigate within the mapped environment. A key component of this package is the `move_base` node, which combines global and local planners to generate a safe and efficient path for the robot to follow. The global planner creates a path from the robot's current position to the desired goal, while the local planner adjusts this path in real-time to avoid obstacles detected by the robot's sensors.

<b>Integration</b>: The `ros_navigation` package works closely with other packages such as `amcl` for localization and `gmapping` for mapping. The localization data from `amcl` informs the navigation stack of the robot's current position, while the map generated by `gmapping` serves as the reference for planning paths. The `move_base` node utilizes this information to navigate the robot to specified goals while avoiding obstacles.

<b>Challenges and Solutions</b>: During the implementation of the `ros_navigation` package, I faced challenges with the robot getting stuck in tight spaces or failing to navigate around obstacles. To address this, I fine-tuned the parameters for the `move_base` node, specifically adjusting the costmap settings and the robot's footprint to improve obstacle avoidance behavior. Additionally, I ensured that the sensor data was being processed accurately to provide timely updates to the navigation stack.

<b>References</b>: For more information on the `ros_navigation` package, you can refer to the [ROS Navigation Stack](http://wiki.ros.org/navigation) documentation.

## 1. Clone and Build
Clone repo and build workspace
```bash
$ mkdir ~/catkin_ws && cd ~/catkin_ws
$ git clone https://github.com/izzianyramli/Udacity-Robotics-Project5.git src
$ git submodule update && git submodule init
$ catkin_make
```
## 2. Mapping
For mapping, run `test_slam.sh`. This will launch 4 separate xterm terminals :
1. Gazebo: `roslaunch my_robot world.launch`. This will use package from `my_robot` to launch Gazebo world (`my_robot/world/HexagonWorld.world`) including the robot model.
2. SLAM: `roslaunch gmapping slam_gmapping_pr2.launch`. This will use package run SLAM algorithm from gmapping package which uses `/scan` data from the robot to map the building in Gazebo environment. 
3. RViz: `roslaunch my_robot view_navigation.launch`. This will run preconfigured RViz to visualize the robot's odometry and scan and also to view the map generated while running SLAM. 
4. Teleop: `roslaunch my_robot teleop.launch`. This launch file will levearage the `teleop_twist_keyboard` package which serves as robot teleoperation package to manually control and move the robot using keyboard while mapping the environment.
```bash
$ cd ~/catkin_ws
$ source devel/setup.bash
$ ./src/scripts/test_slam.sh
```

When you are satisfied with the map, save it by running `map_server` command in new terminal:
```bash
$ rosrun map_server map_saver -f <filename>
```
This will save the .pgm and .yaml file that will be used in Navigation part.

## 3. Navigation
For navigation, run `test_navigation.sh`. This will launch 3 separate xterm terminals :
1. Gazebo: `roslaunch my_robot world.launch`. This will use package from `my_robot` to launch Gazebo world (`my_robot/world/HexagonWorld.world`) including the robot model.
2. AMCL: `roslaunch my_robot amcl.launch`. This uses AMCL package from ROS to run localization and load the saved map.yaml file (`my_robot/maps/map.yaml`).
3. RViz: `roslaunch my_robot view_navigation.launch`. This will run preconfigured RViz to visualize the robot's odometry and position. We will use the `2DNavGoal` in RViz to send navigation goal to the robot move_base node. 
```bash
$ cd ~/catkin_ws
$ source devel/setup.bash
$ ./src/scripts/test_navigation.sh
```

## 4. Navigation with Multiple Goals
To test navigation with multiple goals, run `pick_objects.sh`. This will launch 4 separate xterm terminals : 
1. Gazebo: `roslaunch my_robot world.launch`. This will use package from `my_robot` to launch Gazebo world (`my_robot/world/HexagonWorld.world`) including the robot model.
2. AMCL: `roslaunch my_robot amcl.launch`. This uses AMCL package from ROS to run localization and load the saved map.yaml file (`my_robot/maps/map.yaml`).
3. RViz: `roslaunch my_robot view_navigation.launch`. This will run preconfigured RViz to visualize the robot's odometry and position.
4. Pick Objects: `rosrun pick_objects pick_objects`. This node will send 2 consecutive goals to the robot (pickup point, then dropoff point).
```bash
$ cd ~/catkin_ws
$ source devel/setup.bash
$ ./src/scripts/pick_objects.sh
```

## 5. Virtual Objects
To test for virtual objects in RViz, run `add_markers.sh`. This will launch 4 separate xterm terminals :
1. Gazebo: `roslaunch my_robot world.launch`. This will use package from `my_robot` to launch Gazebo world (`my_robot/world/HexagonWorld.world`) including the robot model.
2. AMCL: `roslaunch my_robot amcl.launch`. This uses AMCL package from ROS to run localization and load the saved map.yaml file (`my_robot/maps/map.yaml`).
3. RViz: `roslaunch my_robot view_navigation.launch`. This will run preconfigured RViz to visualize the robot's odometry and position.
4. Add Markers: `rosrun add_markers add_markers_time`. This node will visualize 2 virtual objects (cube object) in RViz to visualize the pickup and dropoff points. Marker will appear at the pickup point, and after 5 seconds it will hide, and appear at the dropoff point.
```bash
$ cd ~/catkin_ws
$ source devel/setup.bash
$ ./src/scripts/add_markers.sh
```

## 6. Home Service Robot
To test for the end-to-end home service robot application, run `home_service.sh`. This will launch 5 separate xterm terminals :
1. Gazebo: `roslaunch my_robot world.launch`. This will use package from `my_robot` to launch Gazebo world (`my_robot/world/HexagonWorld.world`) including the robot model.
2. AMCL: `roslaunch my_robot amcl.launch`. This uses AMCL package from ROS to run localization and load the saved `map.yaml` file (`my_robot/maps/map.yaml`).
3. RViz: `roslaunch my_robot view_navigation.launch`. This will run preconfigured RViz to visualize the robot's odometry and position.
4. Add Markers: `rosrun add_markers add_markers`. This node will visualize 2 virtual objects (cube object) in RViz to visualize the pickup and dropoff points. Marker will appear at the pickup point, and wait for the robot to reach the pickup point, then disappear. Once the robot reached the dropoff point, it will appear again at the dropoff point.
5. Pick Objects: `rosrun pick_objects pick_objects`. This node will send 2 consecutive goals to the robot (pickup point, then dropoff point).
```bash
$ cd ~/catkin_ws
$ source devel/setup.bash
$ ./src/scripts/home_service.sh
```
